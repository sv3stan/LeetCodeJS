/**
Вам дана сетка двумерного массива с нулевым индексом размером 2 x n, где сетка[r][c] представляет количество точек в позиции (r, c) в матрице. Два робота играют в игру на этой матрице. Оба робота изначально начинают с (0, 0) и хотят достичь (1, n-1). Каждый робот может двигаться только вправо ((r, c) на (r, c + 1)) или вниз ((r, c) на (r + 1, c)). В начале игры первый робот перемещается из (0, 0) в (1, n-1), собирая все точки из клеток на своем пути. Для всех ячеек (r, c), пройденных по пути, Grid[r][c] устанавливается равным 0. Затем второй робот перемещается от (0, 0) к (1, n-1), собирая точки на свой путь. Обратите внимание, что их пути могут пересекаться друг с другом. Первый робот хочет минимизировать количество очков, набранных вторым роботом. Напротив, второй робот хочет максимизировать количество набранных им очков. Если оба робота играют оптимально, верните количество очков, набранных вторым роботом.
 */

function gridGame(grid: number[][]): number {
    const n = grid[0].length;
    const topSum = new Array(n).fill(0);
    const bottomSum = new Array(n).fill(0);

    topSum[n - 1] = grid[0][n - 1];
    for (let i = n - 2; i >= 0; i--) {
        topSum[i] = topSum[i + 1] + grid[0][i];
    }

    bottomSum[0] = grid[1][0];
    for (let i = 1; i < n; i++) {
        bottomSum[i] = bottomSum[i - 1] + grid[1][i];
    }

    let result = Infinity;
    for (let i = 0; i < n; i++) {
        const pointsTop = i + 1 < n ? topSum[i + 1] : 0;
        const pointsBottom = i - 1 >= 0 ? bottomSum[i - 1] : 0;
        const secondRobotPoints = Math.max(pointsTop, pointsBottom);
        result = Math.min(result, secondRobotPoints);
    }

    return result;
}
