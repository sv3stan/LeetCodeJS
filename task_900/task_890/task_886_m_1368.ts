/**
Дана сетка m x n. В каждой ячейке сетки есть знак, указывающий на следующую ячейку, которую вам следует посетить, если вы в данный момент находитесь в этой ячейке. Знак сетки[i][j] может быть: 1, что означает перейти в ячейку справа. (т.е. перейти от сетки[i][j] к сетке[i][j + 1]) 2, что означает идти в клетку слева. (т.е. перейти от сетки[i][j] к сетке[i][j - 1]) 3, что означает переход в нижнюю ячейку. (т.е. перейти от сетки[i][j] к сетке[i + 1][j]) 4, что означает переход в верхнюю ячейку. (т.е. перейти от сетки[i][j] к сетке[i - 1][j]) Обратите внимание, что в ячейках сетки могут быть знаки, выходящие за пределы сетки. Первоначально вы начнете с верхней левой ячейки (0, 0). Допустимый путь в сетке — это путь, который начинается из верхней левой ячейки (0, 0) и заканчивается в нижней правой ячейке (m — 1, n — 1), следуя знакам в сетке. Действительный путь не обязательно должен быть кратчайшим. Вы можете изменить знак ячейки со стоимостью = 1. Вы можете изменить знак ячейки только один раз. Возвращает минимальную стоимость, чтобы в сетке был хотя бы один допустимый путь.
 */

const grid = [
    [1, 1, 1, 1],
    [2, 2, 2, 2],
    [1, 1, 1, 1],
    [2, 2, 2, 2],
];

function minCost(grid: number[][]): number {
    const m = grid.length;
    const n = grid[0].length;

    const directions = [
        [0, 1, 0],
        [0, -1, 0],
        [1, 0, 0],
        [-1, 0, 0],
    ];

    const isValid = (x: number, y: number): boolean => {
        return x >= 0 && x < m && y >= 0 && y < n;
    };

    const queue: [number, number, number][] = [];
    const visited: boolean[][] = Array.from({ length: m }, () =>
        Array(n).fill(false),
    );

    queue.push([0, 0, 0]);
    visited[0][0] = true;

    while (queue.length > 0) {
        const [x, y, cost] = queue.shift()!;

        if (x === m - 1 && y === n - 1) {
            return cost;
        }

        for (const [dx, dy, direction] of directions) {
            const newX = x + dx;
            const newY = y + dy;

            if (isValid(newX, newY) && !visited[newX][newY]) {
                visited[newX][newY] = true;
                if (grid[x][y] === direction) {
                    queue.push([newX, newY, cost]);
                } else {
                    queue.push([newX, newY, cost + 1]);
                }
            }
        }
    }
}

console.log(minCost(grid));
