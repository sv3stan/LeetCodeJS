/**
Учитывая целочисленный массив nums, найдите максимально возможное побитовое ИЛИ для подмножества чисел и верните количество различных непустых подмножеств с максимальным побитовым ИЛИ.
Массив a является подмножеством массива b, если a можно получить из b, удалив некоторые (возможно, нулевые) элементы b. Два подмножества считаются разными, если индексы выбранных элементов различны.
Побитовое ИЛИ массива a равно a[0] OR a[1] OR ... OR a[a.length - 1] (с индексом 0).
 */

let nums = [3, 2, 1, 5];

function countMaxOrSubsets(nums: number[]): number {
    const max = nums.reduce((acc, el) => acc | el, 0);

    let count = 0;

    function backtrack(index: number, cur: number): void {
        // Если прошли по всем элементам массива
        if (index === nums.length) {
            // Если побитовое ИЛИ текущего подмножества равно максимальному, увеличиваем счетчик
            if (cur === max) {
                count++;
            }
            return;
        }

        // Вариант 1: включить текущий элемент в подмножество
        backtrack(index + 1, cur | nums[index]);

        // Вариант 2: не включать текущий элемент в подмножество
        backtrack(index + 1, cur);
    }

    // Начинаем с первого элемента и начального значения побитового ИЛИ = 0
    backtrack(0, 0);
    return count;
}

console.log(countMaxOrSubsets(nums));
